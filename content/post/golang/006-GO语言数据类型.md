---
title:          006-GO语言数据类型
date:           2019-06-08T10:20:23+08:00
draft:          true
tags:           [2019-06]
topics:         [Golang,数据类型]
---

## 简介

&nbsp;&nbsp;&nbsp;&nbsp;在Go编程语言中，数据类型用于声明函数和变量。数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。
<!--more-->

## 环境

无

## 软件包

无

## 拓扑图

无


## 正文
---

### 数据类型分类

Go语言根据数据类型进行分类如下：

{{< pure_table
"序号|类型|描述"
"1|布尔型|布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。"
"2|数字类型|整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。"
"3|字符串类型|字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。"
"4|派生类型|包括：a).指针类型（Pointer）    b).数组类型     c).结构化类型(struct)   d).Channel类型  e).函数类型     f).切片类型     g).接口类型（interface）    h).Map类型"
>}}


### 1. 整数

{{< pure_table
"类型名称|有无符号|bit数|描述"
"int8|Yes|8|-128到127"
"int16|Yes|16|-32768到32767"
"int32|Yes|32|-2147483648到2147483647"
"int64|Yes|64|-9223372036854775808到9223372036854775807"
"uint8|No|8|0到255"
"uint16|No|16|0到65535"
"uint32|No|32|0到4294967295"
"uint64|No|64|0到18446744073709551615"
"int|Yes|等于cpu位数|"
"uint|No|等于cpu位数|"
"rune|Yes|与 int32 等价|Unicode字符类型，和int32类型等价，通常用于表示一个Unicode码点。rune和int32可以互换使用。"
"byte|No|与 uint8 等价|uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是 一个小的整数。"
"uintptr|No|-|一种无符号的整数类型，没有指定具体的bit大小但是足以容纳指针。 uintptr类型只有在底层编程是才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。"
>}}

精确的类型有8种：int8/uint8,int16/uint16,int32/uint32,int64/uint64,int型是有符号基本型整数，如果是32位系统，就是32位，同理，64位系统，就是64位的整型

#### 整型运算：

&nbsp;&nbsp;&nbsp;&nbsp;二元运算符：算术运算、逻辑运算和比较运算，运算符优先级从上到下递减顺序排列,在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序。

     *      /     %     <<     >>     &     &^ 
     +      -     |     ^      
     ==     !=    <     <=     >      >=
     &&
     ||

&nbsp;&nbsp;&nbsp;&nbsp;算术运算符+、-、*和/可以适用与于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。 % 取模运算符的符号和被取模数的符号总是一致的。除法运算符/的行为则依赖于操作数是否 全为整数，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。

&nbsp;&nbsp;&nbsp;&nbsp;两个相同的整数类型可以使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型。

    ==    equal to
    !=    not equal to
    <     less than
    <=    less than or equal to
    >     greater than
    >=    greater than or equal to

&nbsp;&nbsp;&nbsp;&nbsp;个算术运算的结果，无论有无符号，超出的高位的bit位部分将被丢弃。如果原始的数值是有符号类型，而且最左边 的bit为是1的话，那么最终结果可能是负的。布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用 == 和 != 进行比较。

一元的加法和减法运算符：

    +      一元加法 (无效果)
    -      负数


bit位操作运算符：


    符号	    操作	    操作数是否区分符号
    &	    位运算 AND	        No
    |	    位运算 OR	        No
    ^	    位运算 XOR	        No
    &^	    位清空 (AND NOT)	No
    <<	    左移	           Yes
    >>	    右移	           Yes


注意:

&nbsp;&nbsp;&nbsp;&nbsp;位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反。位操作运算符&^用于按位置零（AND NOT）：对于表达式z = x &^ y， 如果对应y中某位bit位为 0 的话，结果z的对应的bit位等于x相应的bit位的值，否则 z 对应的bit位为0。

    操作	     含义	            --
    <<	        左移	    左移运算用零填充右边空缺的bit位
    >>	        右移	    无符号数的右移运算用0填充左边空缺的bit位，有符号数的右移运算用符号位的值填充左边空缺的bit位
 

&nbsp;&nbsp;&nbsp;&nbsp;一般来说，需要一个显式的转换将一个值从一种类型转化位另一种类型，并且算术和逻辑运算的二元操 作中必须是相同的类型。虽然这偶尔会导致需要很长的表达式，但是它消除了所有和类型相关的问题， 而且也使得程序容易理解。

&nbsp;&nbsp;&nbsp;&nbsp;许多整形数之 间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值。但是对于将一个大尺寸的整数类 型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度。 浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格 式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。


    package main

    import "fmt"

    func main() {
    	// 无符号整形，默认值都是0,Go 1.9版本对于数字类型，无需定义int及float32、float64，系统会自动识别。
    	var u8 uint8
    	var u16 uint16
    	var u32 uint32
    	var u64 uint64
    	fmt.Printf("u8: %d, u16: %d, u32: %d, u64: %d\n", u8, u16, u32, u64) // 默认值都为0
    	u8 = 255
    	u16 = 65535
    	u32 = 4294967295
    	u64 = 18446744073709551615
    	fmt.Printf("u8: %d, u16: %d, u32: %d, u64: %d\n", u8, u16, u32, u64)

    	// 整型
    	var i8 int8
    	var i16 int16
    	var i32 int32
    	var i64 int64
    	fmt.Printf("i8: %d, i16: %d, i32: %d, i64: %d\n", i8, i16, i32, i64) // 默认值都为0
    	i8 = 127
    	i16 = 32767
    	i32 = 2147483647
    	i64 = 9223372036854775807
    	fmt.Printf("i8: %d, i16: %d, i32: %d, i64: %d\n", i8, i16, i32, i64)

    	// int 型，取值范围32位系统为 int32，64位系统为 int64，取值相同但为不同类型
    	var i int
    	//i = i32 // 报错，编译不通过，类型不同
    	//i = i64 // 报错，编译不通过，类型不同
    	i = -9223372036854775808
    	fmt.Println("i: ", i)

    	var a int
    	a = 10
    	fmt.Println(a*5, a/5, a%5, a-5)
    	fmt.Println(a == 10, a == 5, a != 5, a != 10, a < 5, a > 5, a >= 10, a >= 5, a <= 10, a <= 5)
    	// 10转换二进制为1010,左移动一位为10100,转换十进制为20;右移一位为101,转换十进制为5.
    	fmt.Println(a<<1, a>>1)
    	//按位与运算(&) 转换成二进制,1010与0001与计算,1010与0101与计算,1010与1010与计算结果为0000,0000,1010,也就是0&0=0;0&1=0;1&0=0;1&1=1;两位同时为“1”,结果才为“1”,否则为0
    	fmt.Println(a&1, 5&a, 10&a)
    	//按位或运算(|) 转换成二进制,1010与0001或计算,1010与0101或计算,1010与1010或计算结果为1011,1111,1010,也就是0|0=0;0|1=1;1|0=1;1|1=1;参加运算的两个对象只要有一个为1,其值  为1.
    	fmt.Println(a|1, a|5, a|10)
    	//异或运算(^) 转换成二进制,1010与0001异或运算,1010与0101异或运算,1010与1010异或运算结果为1011,1111,0000,也就是0^0=0,0^1=1;1^0=1;1^1=0;参加运算的两个对象，如果两个相应  位为“异”（值不同），则该位结果为1，否则为0。
    	fmt.Println(a^1, a^5, a^10)
    	//位清空运算（&^）转换成二进制,1010与0001位清空运算,1010与0101位清空运算,1010与1010位清空运算结果为1010,1010,0000,也就是0&^0=0&1=0,0&^1=0&0=0,1&^0=1&1=1;1&^1=1&    1=1;即z = x &^ y运算相当于先把y取反（针对y的每个bit：0变成1，1变成0），然后再和x进行&运算。
    	fmt.Println(a&^1, a&^5, a&^10)
    }


### 2. 浮点数

{{< pure_table
"类型名称|bit数|描述"
"float32|32|IEEE-754 32位浮点型数"
"float64|64|IEEE-754 64位浮点型数"
>}}

&nbsp;&nbsp;&nbsp;&nbsp;Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义， 该浮点数规范被所有现代的CPU支持。这些浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在math包找到。常量 math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是 1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度。

&nbsp;&nbsp;&nbsp;&nbsp;函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。虽然可以用math.NaN来 表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的。 如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败。


    package main

    import (
    	"fmt"
    	"reflect"
    )

    func main() {

    	// 浮点型，f32精度6位小数，f64位精度15位小数
    	var f32 float32
    	var f64 float64
    	fmt.Printf("f32: %f, f64: %f\n", f32, f64) // 默认值都为 0.000000
    	f32 = 1.12345678
    	f64 = 1.12345678901234567
    	fmt.Printf("f32: %v, f64: %v\n", f32, f64) // 末位四舍五入，输出：f32: 1.1234568, f64: 1.1234567890123457
    	fmt.Println(f32+3.8765432, reflect.TypeOf(f32+3.8765432))
    	fmt.Println(f32*5, f32/5, f32-1)
    }



### 3. 复数

{{< pure_table
"类型名称|bit数|描述"
"complex64|32|32位实数和虚数"
"complex128|64|64位实数和虚数"
>}}

&nbsp;&nbsp;&nbsp;&nbsp;Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部。

    z := x + yi
    x = real(z)
    y = imag(z)

&nbsp;&nbsp;&nbsp;&nbsp;复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的。 math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。

    package main

    import "fmt"

    func main() {

    	// 复数型
    	var c64 complex64
    	var c128 complex128
    	fmt.Printf("c64: %v, c128: %v\n", c64, c128) // 实数、虚数的默认值都为0
    	c64 = 1.12345678 + 1.12345678i
    	c128 = 2.1234567890123456 + 2.1234567890123456i
    	fmt.Printf("c64: %v, c128: %v\n", c64, c128) // 输出：c64: (1.1234568+1.1234568i), c128: (2.1234567890123457+2.1234567890123457i)
    	fmt.Println(c64+1, c64/5, c64-1)
    }


### 4. 布尔型

&nbsp;&nbsp;&nbsp;&nbsp;一个布尔类型的值只有两种：true和false。if和for语句的条件部分都是布尔类型的值，并且==和<等比 较操作也会产生布尔型的值。一元操作符!对应逻辑非操作，因此!true的值为false。布尔值可以和&&（AND）和||（OR）操作符结合，并且可能会有短路行为：如果运算符左边值已经可以确 定整个布尔表达式的值，那么运算符右边的值将不在被求值,布尔值并不会隐式转换为数字值0或1，反之亦然。必须使用一个显式的if语句辅助转换。

逻辑操作符：

!：逻辑非操作符；

||：逻辑或操作符；

&&：逻辑与操作符

比较操作符。

<，>， ==，!=， <=， >=

#### 代码实例

    package main

    import "fmt"

    func main() {
    	var v1, v2 bool       // 声明变量，默认值为 false
    	v1 = true             // 赋值
    	v3, v4 := false, true // 声明并赋值

    	fmt.Print(v1, "\n")          // v1 输出 true
    	fmt.Print(v2, "\n")          // v2 没有重新赋值，显示默认值：false
    	fmt.Print(v3, "\n")          // v3 false
    	fmt.Print(v4, "\n")          // v4 true
    	fmt.Print(!v4, "\n")         // 非运算,flase
    	fmt.Print(false || v4, "\n") // 或运算,true
    	fmt.Print(true || v4, "\n")  // 或运算,true
    	fmt.Print(false || v3, "\n") // 或运算,false
    	fmt.Print(true && v4, "\n")  // 与运算,true
    	fmt.Print(false && v4, "\n") // 与运算,false
    	fmt.Print(false && v3, "\n") // 或运算,false
    	fmt.Print(1 > 2, "\n")       // 比较运算大于,false
    	fmt.Print(1 < 2, "\n")       // 比较运算小于,true
    	fmt.Print(1 == 2, "\n")      // 比较运算等于,false
    	fmt.Print(1 != 2, "\n")      // 比较运算不等于,true
    	fmt.Print(1 >= 2, "\n")      // 比较运算大于等于,false
    	fmt.Print(1 <= 2, "\n")      // 比较运算小于等于,true
    }


### 5. 字符串

&nbsp;&nbsp;&nbsp;&nbsp;字符串是一系列8位字节的集合，通常但不一定代表UTF-8编码的文本。字符串可以为空，但不能为nil。而且字符串的值是不能被更改，但可以被替换,其中string类型是Golang中另一个重要的内建类型,所有的string在底层都是这样的一个结构体stringStruct{str: str_point, len: str_len}，string结构体的str指针指向的是一个字符常量的地址， 这个地址里面的内容是不可以被改变的，因为它是只读的，但是这个指针可以指向不同的地址。string类型占用16字节空间，前8字节是一个指针，指向字符串值的地址，后八个字节是一个整数，标识字符串的长度；注意go语言的字符串内部并不以'\0'作为结尾，而是通过一个长度域来表示字符串的长度。

    package main

    import "fmt"

    func main() {

    	// 字符型
    	var b byte                                       // uint8 别名
    	var r1, r2 rune                                  // uint16 别名
    	fmt.Printf("b: %v, r1: %v, r2: %v\n", b, r1, r2) // 默认值为0
    	b = 'a'
    	r1 = 'b'
    	r2 = '字'
    	fmt.Printf("b: %v, r1: %v, r2: %v\n", b, r1, r2) // 输出：b: 97(ASCII表示的数), r1: 98(utf-8表示的数), r2: 23383 (utf-8表示的数)
    }

___
## 结束